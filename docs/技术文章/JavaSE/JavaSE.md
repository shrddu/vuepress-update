---
title: Java面向对象
date: 2022-10-14
categories:
 - JavaSE
tags:
 - 面向对象
---

# Java面向对象编程

1. 

![](E:\MD笔记\Java语言学习\Snipaste_2022-01-26_19-01-39.png)

2. 局部变量没有初始化值，**在调用局部变量之前，一定要显式赋值，在方法内定义变量一定要赋值，对于方法的形参（成员变量）我们调用时赋值即可**

3. 方法的使用中可以调用当前类的属性或方法，**方法中不可以定义方法**。

4. **面向对象编程的继承性**

   - 继承性的格式：class A extends B{}
     - A：子类、派生类、subclass
     - B:父类、超类、基类、superclass
     
   - 体现：继承父类的属性和方法（不能继承构造器）

   - 优点：
     - 减少了代码的冗余，提高了代码的复用性
     - 便于功能的扩展
     - 为多态性的使用，提供了基础
     
   - 注意：
     - **父类私有的属性或方法子类也会继承，只不过因为封装性的影响无法直接访问父类私有的属性或方法，仍然可以 ” 间接 “ 使用私有属性**。如果父类中有对私有属性的get和set的方法，而且是public的修饰的方法，
     
       子类在继承父类的同时，也继承了带有public修饰的set和get方法，所以可以通过以下方式子类可以访问到父类的私有属性。
     
     - 规定：
       - 一个类可以被多个子类继承
       - Java中类的单继承性：一个类只能有一个父类
       - 子父类是相对的概念
       - 子类直接继承的父类称为直接父类，间接继承的父类称为间接父类
       - 子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法
       - ![](E:\MD笔记\Java语言学习\Snipaste_2022-01-30_00-33-07.png)
     
   - 所有我们没有显式定义的声明一个类的父亲的话，则此类继承与java.lang.Object类

   - 所有的java类（除java.lang.Object类之外）都直接或间接的继承与Object类

   - 意味着**所有的Java类都具有java.lang.Object类声明的功能**

5. **重写（override/overwrite）**

   1. 重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作

   2. 应用：**重写以后**，当创建子类对象以后，**通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法**。

   3. 重写的规定：

      1. 方法的声明： 权限修饰符  返回值类型  方法名(形参列表) throws 异常的类型{

          ​		//方法体

         ​	 }

      2. 约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法

      3. **子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同**

         ​	特殊情况：**子类不能重写父类中声明为private权限的方法**“

         > private是私有的,其他类是不能访问的,子类也不可以访问,所以你可以重新实现父类的该方法,不会有冲突,但是你重新实现的方法,不叫重写也不叫重载,是一个该子类新增的方法,和子类的一般扩展方法一样”

      4. 返回值类型：  

         ​	**父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void**

         ​	父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是**A类或A类的子类**

         ​	**父类被重写的方法的返回值类型是基本数据类型(比如：int)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是int)**                                                            

      5. **子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（具体放到异常处理时候讲）**
      
      6. **子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写）。**	

6. super关键字的使用
   1.super理解为：父类（间接父类和直接父类）的
   2.super可以用来调用：属性、方法、构造器

   3.super的使用：调用属性和方法

   ​	3.1 我们可以在子类的方法或构造器中。通过使用"super.属性"或"super.方法"的方式，**显式的调用**
   **​	父类中声明的属性或方法。但是，通常情况下，我们习惯省略"super."**
   ​	3.2 特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显	式的
   ​	使用"super.属性"的方式，表明调用的是父类中声明的属性。
   ​	3.3 **特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必	须显式的**
   **​	使用"super.方法"的方式，表明调用的是父类中被重写的方法。**

     4.super调用构造器
       4.1 我们可以在子类的构造器中显式的使用"super(形参列表)"的方式，调用父类中声明的指定的构造器
       4.2 **"super(形参列表)"的使用，必须声明在子类构造器的首行！**
       4.3 **我们在类的构造器中，针对于"this(形参列表)"或"super(形参列表)"只能二选一，不能同时出现**
       4.4 在构造器的首行，没有显式的声明"this(形参列表)"或"super(形参列表)"，则**默认调用的是父类中空参的构造器：super()**
       4.5 在类的多个构造器中，**至少有一个类的构造器中使用了"super(形参列表)"**，调用父类中的构造器

7. 面向对象特征之三：多态性

   1. 对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）

   2. 多态的使用：虚拟方法调用
      1. **有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。总结：编译，看左边；运行，看右边。（例子： Person p1=new Man() ;  其中 Man 是 Person 的子类）**
      
   3. **多态性的使用前提：  ① 类的继承关系  ② 方法的重写**

   4. **对象的多态性，只适用于方法，不适用于属性（属性的编译和运行都看左边）**

   5. 多态性是运行时行为：因为只有当运行时才可以确定形参子类是哪一个具体的类；不能调用子类特有的属性和方法 

   6. 使用强转：Person p1= new Man ( ) ;  Man m1=(Man)p1 ; 进行强行转换，有可能会出现转换失败情况，比如new的时候new的是Woman，结果强转为Man，就会报错

   7. 多态中，当传入父类形参的参数个数一定时，优先调用确定参数个数的方法

8. **instanceof关键字的使用**

   1. a instanceof A:判断**对象a**是否是**类A**的实例。如果是，返回true；如果不是，返回false。
   2. 使用情境：为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。如果类B是类A的父类，且 a instanceof A返回true，则 a instanceof B 也返回true

   1. ![](E:\MD笔记\Java语言学习\Snipaste_2022-01-31_19-28-47.png)

9. == 和 equals() 区别

     1. == ：运算符：可以使用在基本数据类型变量和引用数据类型变量中 

     2.    如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同）；

     3. 如果比较的是引用数据类型变量：比较两个对象的地址值是否相同 . 即两个引用是否指向同一个对象实体 ；

     4.  补充： == 符号使用时，必须保证符号左右两边的变量类型一致。

     5. equals()方法的使用：

        1. 是一个方法，而非运算符

        2. 只能适用于引用数据类型

        3. Object类中equals()的定义：

        4. ```java
           public boolean equals(Object obj) {
           	        return (this == obj);
           	  }
           说明：Object类中定义的equals()和==的作用是相同的：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体
           ```

        5. **像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的"实体内容"是否相同。**

        6. 通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的"实体内容"是否相同。那么，我们就需要对Object类中的equals()进行重写 . 重写的原则：比较两个对象的实体内容是否相同.

        7. equal()的重写可以用IDE自动生成

        8. **任何情况下x.equal(null),永远返回false**

        9. **equals（）只会比较属性**
        
        9. 重写equals时一定要重写hashcode，这是为了方便使用set集合时准确去重，详细看：[面试官：重写 equals 时为什么一定要重写 hashCode？ - 腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1910930) 其中的3.2 - 3.4

10. Object类中toString()的使用：

     1. 当我们输出一个**对象**的引用时，实际上就是调用当前对象的toString()

     2. Object类中toString()的定义：

     3. ```java
        public String toString() {
                return getClass().getName() + "@" + Integer.toHexString(hashCode());
             }
        ```

     4. **像String、Date、File、包装类等都重写了Object类中的toString()方法。使得在调用对象的toString()时，返回"实体内容"信息**

     5. 自定义类也可以重写toString()方法，当调用此方法时，返回对象的"实体内容"

11. Java中的 JUnit 单元测试

       步骤：
       1.选中当前工程 - 右键选择：build path - add libraries - JUnit 4 - 下一步
       2.创建Java类，进行单元测试。
         此时的Java类要求：① 此类是public的  ②此类提供公共的无参的构造器
       3.此类中声明单元测试方法。
         此时的单元测试方法：方法的权限是public,没有返回值，没有形参

       4.此单元测试方法上需要声明注解：@Test,并在单元测试类中导入：import org.junit.Test;

       5.声明好单元测试方法以后，就可以在方法体内测试相关的代码。
       6.写完代码以后，左键双击单元测试方法名，右键：run as - JUnit Test

      7. **开发中可以直接在一个公共类里注解Test，然后点击Test自动导包，然后声明测试类，进行测试**

        说明：
        1.如果执行结果没有任何异常：绿条
        2.如果执行结果出现异常：红条

12. 包装类（Wrapper）的使用:

      1. JDK 5.0 新特性：自动装箱 与自动拆箱

         ```java
         //自动装箱：基本数据类型 --->包装类
         		int num2 = 10;
         		Integer in1 = num2;//自动装箱
         		
         		boolean b1 = true;
         		Boolean b2 = b1;//自动装箱
         		
         		//自动拆箱：包装类--->基本数据类型
         		
         		int num3 = in1;//自动拆箱
         ```

      2. java提供了8种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征

      3. 需要掌握的：基本数据类型、包装类、String三者之间的相互转换

      4. 包装类--->基本数据类型:调用包装类Xxx的xxxValue()

      5. ```java
         Integer in1 = new Integer(12);
         
         int i1 = in1.intValue();
         System.out.println(i1 + 1);
         
         Float f1 = new Float(12.3);
         float f2 = f1.floatValue();
         System.out.println(f2 + 1);
         ```
         
      6. String类型 --->基本数据类型、包装类：调用包装类的parseXxx(String s)
    
      ```java
      int num2 = Integer.parseInt(str1);
      System.out.println(num2 + 1);
      		
      String str2 = "true1";
      boolean b1 = Boolean.parseBoolean(str2);//只有字符串为"true"才会返回true，其他都是false
      System.out.println(b1);
      ```
    
      4. 基本数据类型、包装类--->String类型：调用String重载的valueOf(Xxx xxx)
    
      ```java
      //方式1：连接运算
      String str1 = num1 + "";
      //方式2：调用String的valueOf(Xxx xxx)
      float f1 = 12.3f;
      String str2 = String.valueOf(f1);//"12.3"
      
      Double d1 = new Double(12.4);
      String str3 = String.valueOf(d1);
      System.out.println(str2);
      System.out.println(str3);//"12.4"
      ```
    
13. static关键字的使用

        1.static:静态的
        2.static可以用来修饰：属性、方法、代码块、内部类
        
        3.使用static修饰属性：静态变量（或类变量）
          	3.1 属性，按是否使用static修饰，又分为：静态属性  vs 非静态属性(实例变量)
          		实例变量：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的
                  非静态属性时，不会导致其他对象中同样的属性值的修改。
             静态变量：**我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致**
                   **其他对象调用此静态变量时，是修改过了的。**
          	3.2 static修饰属性的其他说明：
          		 ① **静态变量（属性、方法）随着类的加载而加载。可以通过"类.静态变量"的方式进行调用，但是方法的加载并不等于方法的调用，只有调用方法时，方法体才会运行**
                   ② **静态变量的加载要早于对象的创建**。
                   ③ 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。
        
        ​		   ④ 加载类中某一个属性或方法时，其他属性或方法会同时加载
        
          	 	④		类变量	实例变量
          		类		yes		no
          		对象		yes		yes
        
        ​	

      3.3 静态属性举例：System.out; Math.PI;           

      4.使用static修饰方法：静态方法
      		① 随着类的加载而加载，可以通过"类.静态方法"的方式进行调用
      		②			静态方法	非静态方法
               类		yes		no
               对象		yes		yes
      		③ **静态方法中，只能调用静态的方法或属性**
            **非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性**

      

        1. static注意点：
             5.1 **在静态的方法内，不能使用this关键字、super关键字**
             5.2 关于静态属性和静态方法的使用，大家都从生命周期的角度去理解。
        
        2. 开发中，如何确定一个属性是否要声明为static的？
        
             属性是可以被多个对象所共享的，不会随着对象的不同而不同的。
             类中的常量也常常声明为static
        
             开发中，如何确定一个方法是否要声明为static的？
              	> 操作静态属性的方法，通常设置为static的
        
             ​	 > 工具类中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections

14. 单例设计模式：

        1. 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。
        
        2. 如何实现？
        
        	 饿汉式  vs 懒汉式
        
        3. 区分饿汉式 和 懒汉式
        
          饿汉式：	
          	坏处：对象加载时间过长。
          	好处：饿汉式是线程安全的
          
          懒汉式：好处：延迟对象的创建。
          	  目前的写法坏处：线程不安全。--->到多线程内容时，再修改
          	  
          无论使用多少次getInstance构造器，都只生成同一个对象

15. main()方法的使用说明：

       1. main()方法作为程序的入口
       2. main()方法也是一个普通的静态方法
       3. main()方法可以作为我们与控制台交互的方式。（之前：使用Scanner）

16. 类的成员之四：代码块（或初始化块）

        1. 代码块的作用：用来初始化类、对象
        2. 代码块如果有修饰的话，只能使用static.
        3. 分类：静态代码块  vs 非静态代码块
        
        4. 静态代码块

      ```
         >内部可以有输出语句
         >随着类的加载而执行,而且只执行一次
         >作用：初始化类的信息
         >如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行
         >静态代码块的执行要优先于非静态代码块的执行
         >静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构
      ```

        5. 非静态代码块

      ```
      	>内部可以有输出语句
      	>随着对象的创建而执行
      	>每创建一个对象，就执行一次非静态代码块
      	>作用：可以在创建对象时，对对象的属性等进行初始化
      	>如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行
      	>非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法
      ```

17. 对属性可以赋值的位置：
       ①默认初始化
       ②显式初始化/⑤在代码块中赋值
       ③构造器中初始化
       ④有了对象以后，可以通过"对象.属性"或"对象.方法"的方式，进行赋值

       执行的先后顺序：① - ② / ⑤ - ③ - ④

18. final:最终的

        1. final可以用来修饰的结构：类（和对象）、方法、变量
        
        2. final 用来修饰一个类:此类不能被其他类所继承。
                 比如：String类、System类、StringBuffer类
        
        3. final 用来修饰方法：表明此方法不可以被重写

      ```
      		比如：Object类中getClass();
      ```

        4. final 用来修饰变量：此时的"变量"就称为是一个常量

      ```
          4.1 final修饰属性：可以考虑赋值的位置有：显式初始化、代码块中初始化、构造器中初始化
      	4.2 final修饰局部变量：
              尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。
      ```
    
         static final 用来修饰属性：全局常量
    
      5. final用来修饰一个对象形参时，这个形参不能再改变，但是这个对象形参的属性可以变
    
19. native修饰方法表明要调用底层的C/C++的代码，native修饰的方法没有大括号及方法体，隐藏了底层

20. abstract关键字的使用
      1.abstract:抽象的
      2.abstract可以用来修饰的结构：**类、方法**

        3. abstract修饰类：抽象类

      ```
         > 此类不能实例化
         > 抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）
         > 开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作
      ```

    ​    

4. abstract修饰方法：抽象方法

抽象方法只有方法的声明，没有方法体
**包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。**
若子类重写了父类中的所有的抽象方法后，此子类方可实例化
若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰

  5. abstract使用上的注意点：
       1.**abstract不能用来修饰：属性、构造器等结构**

       2.**abstract不能用来修饰私有方法、静态方法、final的方法、final的类**

     为什么不能修饰静态方法：

     > 子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写）。
     >
     > 当修饰父类abstract static方法时，子类只能重写父类方法才能用这个方法，但是重写之后子父类又都为static，根据第一句话，这种情况考虑为不是重写，矛盾了。

21. 抽象类的匿名子类

```java
public static void method1(Person p){
		p.eat();
		p.breath();
	}

//创建了一匿名子类的对象：p
		Person p = new Person(){

			@Override//重写了父类Person的方法，生成一个匿名子类
			public void eat() {
				System.out.println("吃东西");
			}

			@Override
			public void breath() {
				System.out.println("好好呼吸");
			}
			
		};

//创建匿名子类的匿名对象

		method1(new Person(){
			@Override
			public void eat() {
				System.out.println("吃好吃东西");
			}

			@Override
			public void breath() {
				System.out.println("好好呼吸新鲜空气");
			}
		});
```

22. 接口的使用
      1.接口使用interface来定义
      2.**Java中，接口和类是并列的两个结构**
      3.如何定义接口：定义接口中的成员	
    
    3.1 JDK7及以前：只能**定义全局常量和抽象方法**
    		>全局常量：public static final的.但是书写时，可以省略不写
    		>抽象方法：public abstract的
    		
    3.2 JDK8：除了定义全局常量和抽象方法之外，还可以**定义静态方法、默认方法**（略）
    
    默认方法解释：[Java中默认方法 - 东功 - 博客园 (cnblogs.com)](https://www.cnblogs.com/z-cg/p/12243779.html#:~:text=Java中默认方法 默认方法是JDK8新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法，Mortal 这个接口，增加了一个,默认方法 r，这个方法有实现体，并且被声明为了default，如以下代码： 这是Mortal 接口，第3行到第5行位默认方法的方法体)
    
    4. **接口中不能定义构造器的！意味着接口不可以实例化**
    5. **接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。**
       **接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。**
       **接口中的方法都是公有的。**
    6. 1.接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 **public abstract** （只能是 public abstract，其他修饰符都会报错）。
       2.接口中可以含有变量，但是接口中的变量会被隐式的指定为 **public static final** 变量（并且只能是 public，用 private 修饰会报编译错误。）
    
      7. **接口方法的实现规则**
         实现接口的方法，相当于重写方法，方法的重写需要满足：**三同一大一小（方法名、返回值类型、参数列表相同；访问权限>=重写前；抛出异常<=重写前）**
      5. Java开发中，接口通过让类去实现(implements)的方式来使用.
         如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化
         如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类
      6. Java类可以实现多个接口   --->弥补了Java单继承性的局限性
    
        格式：class AA extends BB implements CC,DD,EE
    
      7. **接口与接口之间可以继承，而且可以多继承**
    
      8. 接口的具体使用，体现多态性
    
      9. 接口，实际上可以看做是一种规范
    
      10. 接口的使用
            1.接口使用上也满足多态性
            2.接口，实际上就是定义了一种规范
            3.开发中，体会面向接口编程！
    
      12. 接口与抽象父类的差别可能仅仅在于部分属性定义方面，和多继承方面，接口同样可以像父类一样在传入形参时运用多态传入实现类的对象 
    
      13. **接口并不能去继承一个类**，而类可以继承接口 （接口只能继承于接口，而类既可以继承接口，也可以继承类）
    
      14. JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法。（等于说是提供了两个拥有方法体的方法）
    
            1. 
    
                  ```java
                         public interface CompareA {
                  
                          //静态方法
                          public static void method1(){
                              System.out.println("CompareA:北京");
                          }
                          //默认方法（public可省略）
                          public default void method2(){
                              System.out.println("CompareA：上海");
                          }
                  
                          default void method3(){
                              System.out.println("CompareA：上海");
                          }
                      }
                  
                  
                      //知识点2：通过实现类的对象，可以调用接口中的默认方法。
                              //如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法
                  
                      //知识点3：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，
                              //那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法。-->类优先原则
                  
                  	//知识点4.继承并且实现的父类和接口的同名同参属性必须显式区分，继承并且实现的父类和接口同名同参方法如果使用，则父类的方法优先
                  
                      //知识点5：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，
                              //那么在实现类没有重写此方法的情况下，报错。-->接口冲突。
                              //这就需要我们必须在实现类中重写此方法
                  
                  	//知识点6：如何在子类(或实现类)的方法中调用父类、接口中被重写的方法
                  	public void myMethod(){
                  		method3();//调用自己定义的重写的方法
                  		super.method3();//调用的是父类中声明的
                  		//调用接口中的默认方法
                  		CompareA.super.method3();
                  		CompareB.super.method3();
                  	}
                  ```
          
      15. **接口方法的实现规则**
          实现接口的方法，相当于重写方法，方法的重写需要满足：三同一大一小（方法名、返回值类型、参数列表相同；访问权限>=重写前；抛出异常<=重写前）
    
      16. 实现接口是必须将接口中的方法实现,父类实现了的接口方法是会被子类继承的,对于子类来说继承过来的都是父类方法,没有接口的区别了
    
23. 类的内部成员之五：内部类 

      1. Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类

      2.内部类的分类：成员内部类（静态、非静态）  vs 局部内部类(方法内、代码块内、构造器内)

      3.成员内部类：

      		一方面，作为外部类的成员：
      	  			>调用外部类的结构
      	  			>可以被static修饰
      	  			>可以被4种不同的权限修饰
      	  			
      		另一方面，作为一个类：
      			> 类内可以定义属性、方法、构造器等
      			> 可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承
      			> 可以被abstract修饰

      

    
    
    
    
    
      4.关注如下的3个问题
    
    ​    4.1 如何实例化成员内部类的对象
    
    ```java
    	//创建Dog实例(静态的成员内部类):
    		Person.Dog dog = new Person.Dog();
    		dog.show();
        //创建Bird实例(非静态的成员内部类):
    	//Person.Bird bird = new Person.Bird();//错误的
    		Person p = new Person();
    		Person.Bird bird = p.new Bird();
    		bird.sing();
    ```
    
    
    
    ​    4.2 如何在成员内部类中区分调用外部类的结构
    ​		
    
    ```java
    class Person{	
        class Bird{
                String name = "杜鹃";
    
                public Bird(){
    
                    }
    
                public void sing(){
                    System.out.println("我是一只小小鸟");
                    Person.this.eat();//调用外部类的非静态属性
                    eat();
                    System.out.println(age);
                }
    
                public void display(String name){
                    System.out.println(name);//方法的形参
                    System.out.println(this.name);//内部类的属性
                    System.out.println(Person.this.name);//外部类的属性
                }
    	}
    }
    ```
    
    ​    4.3 开发中局部内部类的使用  见《InnerClassTest1.java》
    
    ```java
    public Comparable getComparable(){
        
    		//创建一个实现了Comparable接口的类:局部内部类
    		//方式一：
    //		class MyComparable implements Comparable{
    //
    //			@Override
    //			public int compareTo(Object o) {
    //				return 0;
    //			}
    //			
    //		}
    //		
    //		return new MyComparable();
    		
    		//方式二：匿名实现类匿名对象
    		return new Comparable(){
    
    			@Override
    			public int compareTo(Object o) {
    				return 0;
    			}
    			
    		};
    		
    	}
    ```
    
    5. 在局部内部类的方法中（比如：show）如果调用外部类所声明的方法(比如：method)中的局部变量(比如：num)的话,
       要求此局部变量声明为final的。
    
       	  jdk 7及之前版本：要求此局部变量显式的声明为final的
       	  jdk 8及之后的版本：可以省略final的声明，但默认有final的作用
    
       ```java
       public void method(){
       		//局部变量
       		int num = 10;	
       		class AA{		
       			public void show(){
       //				num = 20;
       				System.out.println(num);			
       			}		
       		}	
       	}
       ```
    
24. 枚举类：

24. 在一个类中定义本身类的对象，必须在对象声明前加static，并且在构造器声明private，使其不能在类外被创建对象，加上之后就不会出现死循环，因为static对象属于类本身，不是某个对象的“属性”，这样在创建类中的自身对象时只会创建对象属性。

25. ```java
    public class Status {
        private final String NAME;
        private Status(String name) {
            this.NAME = name;
        }
        public static final Status FREE = new Status("FREE");
        public static final Status VOCATION = new Status("VOCATION");
        public static final Status BUSY = new Status("BUSY");
        public String getNAME() {
            return NAME;
        }
        @Override
        public String toString() {
            return NAME;
        }
    } 
    ```

    
